#!/usr/bin/env node
'use strict';
const commandLineArgs = require('command-line-args');
const carmi = require('../index');
const path = require('path');
const fs = require('fs-extra');
const {isUpToDate} = require('../src/analyze-dependencies');

const optionDefinitions = [
  { name: 'source', type: String, defaultOption: true, description: 'source filename, which exports a carmi model' },
  { name: 'output', type: String, defaultValue: '', description: 'output filename' },
  { name: 'cwd', type: String, defaultValue: '.', description: 'root directory for carmi files. Needed for babel config' },
  {
    name: 'compiler',
    type: String,
    defaultValue: 'optimizing',
    description: 'compiler version to use naive/simple/optimizing'
  },
  { name: 'debug', type: Boolean, defaultValue: false, description: 'add debug functions to the generated code' },
  { name: 'format', type: String, defaultValue: 'iife', description: 'output format - iife,cjs...' },
  { name: 'name', type: String, defaultValue: 'model', description: 'name of the output module/function' },
  { name: 'prettier', type: Boolean, defaultValue: false, description: 'run prettier on the output' },
  {
    name: 'cache',
    type: String,
    defaultValue: '',
    description: 'caches the generated code in the specified folder if the model did not change'
  },
  { name: 'no-cache', type: Boolean, defaultValue: false, description: 'ignore cache' },
  { name: 'stats', type: String, defaultValue: '', description: 'generate stats file' },
  { name: 'help', type: Boolean, defaultValue: false, description: 'shows this very help message and quits' },
  { name: 'ast', type: Boolean, defaultValue: false }
];

const HELP = `carmi [<options>] <src>
${optionDefinitions
  .filter(v => v.description)
  .map(opt => `--${opt.name} - ${opt.description}`)
  .join('\n')}
`;

async function run() {
  const options = commandLineArgs(optionDefinitions);
  if (options.help) {
    return console.log(HELP);
  }

  const cwd = options['cwd'] || process.cwd()
  require('@babel/register')({
    rootMode: 'upward', extensions: ['.ts', '.js'], cwd
  })
  
  const absPath = path.resolve(process.cwd(), options.source);

  const outFile = options.output || tempFile(absPath)
  // console.log(outFile)
  if (!options['no-cache'] && isUpToDate(absPath, outFile, options.stats)) {
    if (options.output) {
      console.log('output is up to date skipping carmi');
    } else {
      const out = await fs.readFile(outFile, 'utf-8')
      console.log(out);
    }
    return;
  }

  let model;
  try {
    model = require(absPath);
  } catch (e) {
    console.error(`failed to require ${options.source} ${e.stack}`);
    throw e;
  }
  const code = carmi.compile(model, options);
  if (!options.output) {
    console.log(code);
  }
  await fs.outputFile(outFile, code);
}

function tempFile(absPath) {
  const crypto = require('crypto');
  const hash = crypto.createHash('md5').update(absPath).digest("hex");
  // console.log(hash)
  return path.resolve('node_modules/.cache/carmi', hash)
}

run().catch(e => {
  console.log('error ' + e)
  process.exit(1)
});
